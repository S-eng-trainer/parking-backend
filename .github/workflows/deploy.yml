name: CD - Deploy Spring Boot to AWS EC2

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'gradle'

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build JAR
        run: ./gradlew clean bootJar --no-daemon

      - name: Upload Artifact (Debug)
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: build/libs/*.jar

      - name: Copy JAR to EC2
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_SSH_USER || 'ec2-user' }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "build/libs/*.jar"
          target: "/home/${{ secrets.EC2_SSH_USER || 'ec2-user' }}/app"
          strip_components: 2 # Elimina 'build/libs' para que el JAR quede en /app/

      - name: Remote Deploy and Start
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_SSH_USER || 'ec2-user' }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            APP_DIR="/home/${{ secrets.EC2_SSH_USER || 'ec2-user' }}/app"
            cd "$APP_DIR"

            # 1. Identificar el nuevo JAR y estandarizar nombre
            echo "Contenido de $APP_DIR:" 
            ls -la || true
            echo "Contenido de $APP_DIR/build/libs (si existe):"
            ls -la build/libs 2>/dev/null || true

            # Prefer the explicitly copied jar in $APP_DIR, then build/libs
            NEW_JAR=""
            if ls -1t *.jar 1>/dev/null 2>&1; then
              NEW_JAR=$(ls -1t *.jar | head -n1)
            fi
            if [ -z "$NEW_JAR" ] && ls -1t build/libs/*.jar 1>/dev/null 2>&1; then
              NEW_JAR=$(ls -1t build/libs/*.jar | head -n1)
            fi

            # Fallback: search recursively for the most recent jar under APP_DIR
            if [ -z "$NEW_JAR" ]; then
              NEW_JAR=$(find . -type f -name "*.jar" -printf "%T@ %p\n" 2>/dev/null | sort -n -r | head -n1 | awk '{print $2}' || true)
            fi

            if [ -z "$NEW_JAR" ]; then
              echo "FATAL: No se encontró ningún archivo JAR en $APP_DIR ni en build/libs."
              exit 1
            fi

            echo "Instalando nuevo artefacto: $NEW_JAR"
            # Move to incoming name first to avoid races with old discovery
            mv "$NEW_JAR" app-incoming.jar
            chmod 644 app-incoming.jar
            # Atomic replace
            mv -f app-incoming.jar app.jar

            # 2. Detener proceso anterior de forma segura
            echo "Deteniendo procesos previos en puerto 8080..."
            sudo fuser -k 8080/tcp || true
            sleep 2

            # 3. Iniciar aplicación con perfil externo
            echo "Iniciando Spring Boot con perfil de producción..."
            nohup java -jar app.jar \
              --spring.config.location=file:$APP_DIR/application-prod.properties \
              > app.log 2>&1 &
            
            NEW_PID=$!
            echo "App lanzada con PID: $NEW_PID"

            # 4. Verificación de salud (Timeout 60s)
            echo "Esperando a que la aplicación responda..."
            for i in {1..12}; do
              if curl -s localhost:8080 > /dev/null; then
                echo "¡Despliegue exitoso! La aplicación responde."
                exit 0
              fi
              echo "Reintentando salud ($i/12)..."
              sleep 5
            done

            echo "ERROR: La aplicación no inició a tiempo. Revisa app.log"
            tail -n 50 app.log
            exit 1
